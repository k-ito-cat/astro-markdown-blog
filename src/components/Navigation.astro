---
import { HEADING_LEVEL } from "~/constants/headingLevel";

type Props = {
  headings: {
    depth: number;
    slug: string;
    text: string;
  }[];
};

const { headings } = Astro.props;
---

{
  headings.length > 0 && (
    <>
      <div class="relative lg:order-2">
        <nav
          id="navigation"
          class="scrollbar-hide bg-tag fixed top-0 right-0 z-40 h-full w-80 translate-x-full overflow-y-scroll p-6 pt-12 transition-transform duration-300 ease-in-out lg:sticky lg:top-4 lg:order-1 lg:h-max lg:w-auto lg:translate-x-0 lg:overflow-y-auto lg:bg-transparent lg:px-0 lg:py-5"
        >
          <div
            id="navigation-content"
            class="transform transition-all duration-200 ease-in-out lg:max-h-none"
          >
            <ul class="m-0 flex list-none flex-col p-0">
              {headings.map((heading) => (
                <li class="relative">
                  <a
                    href={`#${heading.slug}`}
                    class:list={{
                      "text-primary/80 hover:bg-note/10 hover:text-primary border-meta hover:border-note navigation-link relative block w-full overflow-visible border-l px-4 py-2 text-sm leading-relaxed no-underline transition-all duration-200 ease-in-out": true,
                      "text-[15px] font-semibold":
                        heading.depth === HEADING_LEVEL.TWO,
                      "pl-8": heading.depth === HEADING_LEVEL.THREE,
                    }}
                  >
                    {heading.text}
                  </a>
                </li>
              ))}
            </ul>
          </div>
        </nav>
      </div>
    </>
  )
}

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const hamburgerButton = document.querySelector("#hamburger-button");
    const navigation = document.querySelector("#navigation");
    const overlay = document.querySelector("#mobile-overlay");
    const hamburgerIcon = document.querySelector("#hamburger-icon");
    const closeIcon = document.querySelector("#close-icon");
    const navigationLinks = document.querySelectorAll(
      ".navigation-link",
    ) as NodeListOf<HTMLAnchorElement>;

    if (!navigation) return;

    let isMenuOpen = false;

    const toggleMenu = () => {
      isMenuOpen = !isMenuOpen;

      if (isMenuOpen) {
        // メニューを開く
        navigation.classList.remove("translate-x-full");
        overlay?.classList.remove("opacity-0", "pointer-events-none");
        hamburgerIcon?.classList.add("hidden");
        closeIcon?.classList.remove("hidden");
        document.body.style.overflow = "hidden";
      } else {
        // メニューを閉じる
        navigation.classList.add("translate-x-full");
        overlay?.classList.add("opacity-0", "pointer-events-none");
        hamburgerIcon?.classList.remove("hidden");
        closeIcon?.classList.add("hidden");
        document.body.style.overflow = "";
      }
    };

    if (hamburgerButton) {
      hamburgerButton.addEventListener("click", toggleMenu);
      overlay?.addEventListener("click", () => {
        if (isMenuOpen) toggleMenu();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && isMenuOpen) toggleMenu();
      });
    }
    const extractIdFromHash = (hash: string) => {
      if (!hash) return "";
      const raw = hash.replace(/^#/, "");
      return decodeURIComponent(raw);
    };

    let isProgrammaticScroll = false;
    let programmaticScrollTimeout: number | null = null;

    const suspendObserverUpdates = (duration = 800) => {
      isProgrammaticScroll = true;
      if (programmaticScrollTimeout !== null) {
        window.clearTimeout(programmaticScrollTimeout);
      }
      programmaticScrollTimeout = window.setTimeout(() => {
        isProgrammaticScroll = false;
        programmaticScrollTimeout = null;
      }, duration);
    };

    navigationLinks.forEach((link) => {
      link.addEventListener("click", (event) => {
        const href = link.getAttribute("href");
        if (!href) return;

        const targetId = extractIdFromHash(href);
        if (!targetId) return;

        const targetHeading = document.getElementById(targetId);
        if (!targetHeading) return;

        event.preventDefault();

        if (isMenuOpen) toggleMenu();

        suspendObserverUpdates(1000);

        targetHeading.scrollIntoView({ behavior: "smooth", block: "start" });

        const canonicalHash = ensureHashPrefix(targetHeading.id || targetId);
        currentHash = canonicalHash;
        updateHash(currentHash);
        activateLink(currentHash);
      });
    });

    /**
     * ハッシュが変わったら、ナビゲーションのリンクをハイライトする
     */
    const encodeHash = (value: string) => {
      if (!value) return "";
      const trimmed = value.startsWith("#") ? value.slice(1) : value;
      return `#${encodeURIComponent(trimmed)}`;
    };

    const ensureHashPrefix = (value: string) => {
      if (!value) return "";
      return value.startsWith("#") ? value : `#${value}`;
    };

    const updateHash = (hash: string) => {
      const next = encodeHash(hash);
      if (
        typeof history !== "undefined" &&
        typeof history.replaceState === "function"
      ) {
        history.replaceState(
          null,
          "",
          `${location.pathname}${location.search}${next}`,
        );
      } else if (location.hash !== next) {
        location.hash = next;
      }
    };

    const clearActiveLinks = () => {
      navigationLinks.forEach((link) =>
        link.classList.remove(
          "border-note",
          "bg-note/10",
          "text-primary",
          "inline-block",
        ),
      );
    };

    const activateLink = (hash: string) => {
      clearActiveLinks();
      if (!hash) return;
      const target = Array.from(navigationLinks).find(
        (link) => link.getAttribute("href") === hash,
      );
      if (target) {
        target.classList.add(
          "border-note",
          "bg-note/10",
          "text-primary",
          "inline-block",
        );
      }
    };

    let currentHash = ensureHashPrefix(decodeURIComponent(location.hash || ""));
    activateLink(currentHash);

    const removeHashFromUrl = () => {
      if (!currentHash) return;
      if (
        typeof history !== "undefined" &&
        typeof history.replaceState === "function"
      ) {
        history.replaceState(
          null,
          "",
          `${location.pathname}${location.search}`,
        );
      } else if (location.hash) {
        location.hash = "";
      }
      currentHash = "";
      activateLink(currentHash);
    };

    const syncToLocationHash = () => {
      if (isProgrammaticScroll) return;
      currentHash = ensureHashPrefix(decodeURIComponent(location.hash || ""));
      activateLink(currentHash);
    };

    window.addEventListener("hashchange", syncToLocationHash);

    /**
     * ビューポート内の見出しからアクティブな見出しを選択し、URLハッシュとナビゲーションを同期する
     */
    const observeHeadings = () => {
      const headings = Array.from(
        document.querySelectorAll("h2[id], h3[id]"),
      ).filter(
        (element): element is HTMLElement => element instanceof HTMLElement,
      );
      if (headings.length === 0) return;

      const visibleEntries = new Map<HTMLElement, IntersectionObserverEntry>();
      let rafId = 0;
      const TOP_RESET_THRESHOLD = 48;

      const updateActiveFromVisible = () => {
        rafId = 0;

        const scrollTop =
          typeof window !== "undefined"
            ? window.scrollY ||
              document.documentElement.scrollTop ||
              document.body.scrollTop ||
              0
            : 0;

        if (isProgrammaticScroll) return;

        if (scrollTop <= TOP_RESET_THRESHOLD) {
          if (currentHash) {
            removeHashFromUrl();
          } else {
            clearActiveLinks();
          }
          return;
        }

        if (!visibleEntries.size) return;

        const ordered = headings
          .map((heading) => {
            const entry = visibleEntries.get(heading);
            if (!entry) return null;
            return {
              heading,
              top: entry.boundingClientRect.top,
            };
          })
          .filter((item): item is { heading: HTMLElement; top: number } =>
            Boolean(item),
          )
          .sort((a, b) => a.top - b.top);

        if (!ordered.length) return;

        const candidate =
          ordered.find((item) => item.top >= 0) ?? ordered[ordered.length - 1];

        if (!candidate) return;

        const nextHash = `#${candidate.heading.id}`;
        if (nextHash === currentHash) return;

        currentHash = nextHash;
        updateHash(currentHash);
        activateLink(currentHash);
      };

      const scheduleUpdate = () => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(updateActiveFromVisible);
      };

      const io = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            const target = entry.target;
            if (!(target instanceof HTMLElement)) return;
            if (entry.isIntersecting) {
              visibleEntries.set(target, entry);
            } else {
              visibleEntries.delete(target);
            }
          });
          scheduleUpdate();
        },
        {
          root: null,
          threshold: [0, 0.1, 0.5],
          rootMargin: "-35% 0px -55% 0px",
        },
      );

      headings.forEach((heading) => io.observe(heading));
    };
    observeHeadings();
  });
</script>

<style is:inline>
  .scrollbar-hide {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
  .scrollbar-width-0 {
    scrollbar-width: 0;
  }
  .scrollbar-color-transparent-gray-100 {
    scrollbar-color: transparent transparent;
  }
</style>
